rcore ch2 ch3 中采用 per-process 模型，即每个应用程序(Task)都有一个自己的内核栈(kernel stack)，用于处理从用户模式（U-mode）陷入内核模式（S-mode）时的执行上下文，使用Rust定义如下所示：

```rust
#[repr(align(4096))]
#[derive(Copy, Clone)]
struct KernelStack {
    data: [u8; KERNEL_STACK_SIZE],
}

#[repr(align(4096))]
#[derive(Copy, Clone)]
struct UserStack {
    data: [u8; USER_STACK_SIZE],
}

static KERNEL_STACK: [KernelStack; MAX_APP_NUM] = [KernelStack {
    data: [0; KERNEL_STACK_SIZE],
}; MAX_APP_NUM];

static USER_STACK: [UserStack; MAX_APP_NUM] = [UserStack {
    data: [0; USER_STACK_SIZE],
}; MAX_APP_NUM];
```

内核程序自身的运行（如初始化、调度等）使用另一个栈（通常是 boot stack 或全局内核栈）。

---

ch3 中各应用程序 `TaskContext` 初始化状态：
```rust
    /// Create a new task context with a trap return addr and a kernel stack pointer
    pub fn goto_restore(kstack_ptr: usize) -> Self {
        extern "C" {
            fn __restore();
        }
        Self {
            ra: __restore as usize,
            sp: kstack_ptr,
            s: [0; 12],
        }
    }
	// 其中 kstack_ptr 指向 init_app_cx 初始化的栈帧：
	pub fn init_app_cx(app_id: usize) -> usize {
	    KERNEL_STACK[app_id].push_context(TrapContext::app_init_context(
	        get_base_i(app_id),
			USER_STACK[app_id].get_sp(),
	    ))
	}
	pub fn app_init_context(entry: usize, sp: usize) -> Self {
        let mut sstatus = sstatus::read(); // CSR sstatus
        sstatus.set_spp(SPP::User); //previous privilege mode: user mode
        let mut cx = Self {
            x: [0; 32],
            sstatus,
            sepc: entry, // entry point of app
        };
        cx.set_sp(sp); // app's user stack pointer
        cx // return initial Trap Context of app
    }
```

---

```rust
//ref:: https://github.com/andre-richter/qemu-exit
use core::arch::asm;

const EXIT_SUCCESS: u32 = 0x5555; // Equals `exit(0)`. qemu successful exit

const EXIT_FAILURE_FLAG: u32 = 0x3333;
const EXIT_FAILURE: u32 = exit_code_encode(1); // Equals `exit(1)`. qemu failed exit
const EXIT_RESET: u32 = 0x7777; // qemu reset

pub trait QEMUExit {
    /// Exit with specified return code.
    ///
    /// Note: For `X86`, code is binary-OR'ed with `0x1` inside QEMU.
    fn exit(&self, code: u32) -> !;

    /// Exit QEMU using `EXIT_SUCCESS`, aka `0`, if possible.
    ///
    /// Note: Not possible for `X86`.
    fn exit_success(&self) -> !;

    /// Exit QEMU using `EXIT_FAILURE`, aka `1`.
    fn exit_failure(&self) -> !;
}

/// RISCV64 configuration
pub struct RISCV64 {
    /// Address of the sifive_test mapped device.
    addr: u64,
}

/// Encode the exit code using EXIT_FAILURE_FLAG.
const fn exit_code_encode(code: u32) -> u32 {
    (code << 16) | EXIT_FAILURE_FLAG
}

impl RISCV64 {
    /// Create an instance.
    pub const fn new(addr: u64) -> Self {
        RISCV64 { addr }
    }
}

impl QEMUExit for RISCV64 {
    /// Exit qemu with specified exit code.
    fn exit(&self, code: u32) -> ! {
        // If code is not a special value, we need to encode it with EXIT_FAILURE_FLAG.
        let code_new = match code {
            EXIT_SUCCESS | EXIT_FAILURE | EXIT_RESET => code,
            _ => exit_code_encode(code),
        };

        unsafe {
            asm!(
                "sw {0}, 0({1})",
                in(reg)code_new, in(reg)self.addr
            );

            // For the case that the QEMU exit attempt did not work, transition into an infinite
            // loop. Calling `panic!()` here is unfeasible, since there is a good chance
            // this function here is the last expression in the `panic!()` handler
            // itself. This prevents a possible infinite loop.
            loop {
                asm!("wfi", options(nomem, nostack));
            }
        }
    }

    fn exit_success(&self) -> ! {
        self.exit(EXIT_SUCCESS);
    }

    fn exit_failure(&self) -> ! {
        self.exit(EXIT_FAILURE);
    }
}

const VIRT_TEST: u64 = 0x100000;

pub const QEMU_EXIT_HANDLE: RISCV64 = RISCV64::new(VIRT_TEST);


```


---

栈指针越界实验

ch3使用如下代码：
```rust
pub fn shutdown() -> ! {
    sbi_call(SBI_SHUTDOWN, 0, 0, 0);
    panic!("It should shutdown!");
}

/// general sbi call
#[inline(always)]
fn sbi_call(which: usize, arg0: usize, arg1: usize, arg2: usize) -> usize {
    let mut ret;
    unsafe {
        asm!(
            "ecall",
            inlateout("x10") arg0 => ret,
            in("x11") arg1,
            in("x12") arg2,
            in("x16") 0,
            in("x17") which,
        );
    }
    ret
}
```
来关机，但不知道为什么无法关机从而执行`panic!("It should shutdown!");`，而`panic!("It should shutdown!");`又会调用`shutdown()`，从而无限递归开栈，最终sp指针越界，参数覆盖数据段导致输出乱码，最后机器卡住，例如：
```
[kernel] Panicked at src/sbi.rs:53 It should shutdown!
[kernel] Panicked at src/sbi.rs:53 It should shutdown!
[kernel] Panicked at src/sbi.rs:53 It should shutdown!
[kernel] Panicked at src/sbi.rs:53b[kernel] Panicked at src/trap/mod.rs:91bsrc/trap/mod.rs+"K Àâ"à,"
                                                                                                     ÿÿ#'91bsrc/trap/mod.rs+"K Àâ"à,"
                                                                                                                                      ÿÿ#'91bsrc/trap/mod.rs+"K Àâ"à,"
               ÿÿ#'91bsrc/trap/mod.rs+"K Àâ"à,"
                                                ÿÿ#'91bbbbbbbbbbbaaaaaaaaaaaaaaa
```

实践发现，当注释掉 trap/mod.rs 中的println!函数后输出乱码量较少，而保留println!函数会导致输出更多乱码。甚至在代码中任何地方加入：
```rust
fn test() {}
while (0 == test as usize) {
	let c = for a in 1..2 {};
}
```
这种不会被优化掉但也肯定不会被执行的代码也会使输出的乱码量不同。
所以推测原理是：增加代码量后.data段向高地址方向移动，导致sp越界后压入参数正好覆盖数据段中"Panicked at src/sbi.rs:53 It should shutdown!"字符串末尾的结束符，导致输出大量乱码，最后参数覆盖正在执行的.text段导致机器不断执行未知指令卡住。

如果在panic handler中加上：
```rust
global_asm!(include_str!("spup.S"));
extern "C" {
    fn __spup();
}

unsafe {__spup();}
shutdown()
```
spup.S:
```gas
__spup:
  addi sp, sp, 60*8
  ret
```
就不会输出乱码，而是不停输出"Panicked at src/sbi.rs:53 It should shutdown!"，这验证了这一想法。

将shutdown()函数修改为：
```rust
pub fn shutdown() -> ! {
        unsafe {
            asm!(
                "sw {0}, 0({1})",
                in(reg)0x5555, in(reg)(0x100000)
            );

            // For the case that the QEMU exit attempt did not work, transition into an infinite
            // loop. Calling `panic!()` here is unfeasible, since there is a good chance
            // this function here is the last expression in the `panic!()` handler
            // itself. This prevents a possible infinite loop.
            loop {
                asm!("wfi", options(nomem, nostack));
            }
        }
    // sbi_call(SBI_SHUTDOWN, 0, 0, 0);
    panic!("It should shutdown!");
}
```
就可以正常关机了
output:
```output
Test write A OK!
Test write B OK!
Test write C OK!
[kernel] Panicked at src/task/mod.rs:135 All applications completed!
```